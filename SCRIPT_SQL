Вот DDL-скрипты для создания таблиц, а также SQL-запросы для выполнения заданий:  

### 1. DDL-скрипты для создания таблиц:
```sql
CREATE TABLE CLIENTS (
    ID SERIAL PRIMARY KEY,
    NAME VARCHAR(255) NOT NULL,
    PLACE_OF_BIRTH VARCHAR(255),
    DATE_OF_BIRTH DATE,
    ADDRESS TEXT,
    PASSPORT VARCHAR(50) UNIQUE NOT NULL
);

CREATE TABLE PRODUCT_TYPE (
    ID SERIAL PRIMARY KEY,
    NAME VARCHAR(100) NOT NULL,
    BEGIN_DATE DATE NOT NULL,
    END_DATE DATE,
    TARIF_REF INT REFERENCES TARIFS(ID)
);

CREATE TABLE PRODUCTS (
    ID SERIAL PRIMARY KEY,
    PRODUCT_TYPE_ID INT NOT NULL REFERENCES PRODUCT_TYPE(ID),
    NAME VARCHAR(100) NOT NULL,
    CLIENT_REF INT NOT NULL REFERENCES CLIENTS(ID),
    OPEN_DATE DATE NOT NULL,
    CLOSE_DATE DATE
);

CREATE TABLE ACCOUNTS (
    ID SERIAL PRIMARY KEY,
    NAME VARCHAR(100) NOT NULL,
    SALDO DECIMAL(15,2) NOT NULL DEFAULT 0,
    CLIENT_REF INT NOT NULL REFERENCES CLIENTS(ID),
    OPEN_DATE DATE NOT NULL,
    CLOSE_DATE DATE,
    PRODUCT_REF INT NOT NULL REFERENCES PRODUCTS(ID),
    ACC_NUM VARCHAR(50) UNIQUE NOT NULL
);

CREATE TABLE RECORDS (
    ID SERIAL PRIMARY KEY,
    DT BOOLEAN NOT NULL, -- 1 (дебет) уменьшает saldo, 0 (кредит) увеличивает
    ACC_REF INT NOT NULL REFERENCES ACCOUNTS(ID),
    OPER_DATE DATE NOT NULL,
    SUM DECIMAL(15,2) NOT NULL CHECK (SUM > 0)
);

CREATE TABLE TARIFS (
    ID SERIAL PRIMARY KEY,
    NAME VARCHAR(100) NOT NULL,
    COST DECIMAL(10,2) NOT NULL CHECK (COST >= 0)
);
```

---

### 2-3. Наполнение тестовыми данными:
```sql
INSERT INTO CLIENTS (NAME, PLACE_OF_BIRTH, DATE_OF_BIRTH, ADDRESS, PASSPORT) VALUES 
('Иван Иванов', 'Москва', '1985-04-12', 'ул. Пушкина, д. 10', '1234 567890'),
('Петр Петров', 'Санкт-Петербург', '1990-07-21', 'пр. Невский, д. 20', '2345 678901');

INSERT INTO PRODUCT_TYPE (NAME, BEGIN_DATE, END_DATE) VALUES 
('КРЕДИТ', '2023-01-01', NULL),
('ДЕПОЗИТ', '2023-01-01', NULL),
('КАРТА', '2023-01-01', NULL);

INSERT INTO PRODUCTS (PRODUCT_TYPE_ID, NAME, CLIENT_REF, OPEN_DATE) VALUES 
(1, 'Кредит наличными', 1, '2023-06-01'),
(2, 'Депозит 10%', 2, '2023-07-01');

INSERT INTO ACCOUNTS (NAME, SALDO, CLIENT_REF, OPEN_DATE, PRODUCT_REF, ACC_NUM) VALUES 
('Счет по кредиту', 0, 1, '2023-06-01', 1, '40817810100000000001'),
('Счет по депозиту', 0, 2, '2023-07-01', 2, '40817810100000000002');

INSERT INTO RECORDS (DT, ACC_REF, OPER_DATE, SUM) VALUES 
(1, 1, '2023-06-10', 50000),
(0, 2, '2023-07-10', 30000);
```

---

### 4. Выборка счетов по продуктам типа "ДЕПОЗИТ", если у клиента нет "КРЕДИТ":
```sql
SELECT A.*
FROM ACCOUNTS A
JOIN PRODUCTS P ON A.PRODUCT_REF = P.ID
JOIN PRODUCT_TYPE PT ON P.PRODUCT_TYPE_ID = PT.ID
WHERE PT.NAME = 'ДЕПОЗИТ'
AND P.CLIENT_REF NOT IN (
    SELECT DISTINCT CLIENT_REF 
    FROM PRODUCTS 
    WHERE PRODUCT_TYPE_ID = (SELECT ID FROM PRODUCT_TYPE WHERE NAME = 'КРЕДИТ')
);
```

---

### 5. Сумма движений по счетам за один день в разрезе типа продукта:
```sql
SELECT PT.NAME AS PRODUCT_TYPE, R.OPER_DATE, 
       SUM(CASE WHEN R.DT = 1 THEN R.SUM ELSE 0 END) AS TOTAL_DEBIT,
       SUM(CASE WHEN R.DT = 0 THEN R.SUM ELSE 0 END) AS TOTAL_CREDIT
FROM RECORDS R
JOIN ACCOUNTS A ON R.ACC_REF = A.ID
JOIN PRODUCTS P ON A.PRODUCT_REF = P.ID
JOIN PRODUCT_TYPE PT ON P.PRODUCT_TYPE_ID = PT.ID
WHERE R.OPER_DATE = '2023-06-10'
GROUP BY PT.NAME, R.OPER_DATE;
```

---

### 6. Клиенты с операциями за прошлый месяц:
```sql
SELECT C.NAME, R.OPER_DATE, 
       SUM(CASE WHEN R.DT = 1 THEN R.SUM ELSE 0 END) AS TOTAL_DEBIT
FROM CLIENTS C
JOIN ACCOUNTS A ON C.ID = A.CLIENT_REF
JOIN RECORDS R ON A.ID = R.ACC_REF
WHERE R.OPER_DATE >= CURRENT_DATE - INTERVAL '1 month'
GROUP BY C.NAME, R.OPER_DATE;
```

---

### 7. Нормализация остатков:
```sql
UPDATE ACCOUNTS A
SET SALDO = (SELECT COALESCE(SUM(CASE WHEN R.DT = 0 THEN R.SUM ELSE -R.SUM END), 0) 
             FROM RECORDS R WHERE R.ACC_REF = A.ID)
WHERE EXISTS (SELECT 1 FROM RECORDS R WHERE R.ACC_REF = A.ID);
```

---

### 8. Клиенты, погасившие кредит, но не закрывшие продукт:
```sql
SELECT DISTINCT C.*
FROM CLIENTS C
JOIN PRODUCTS P ON C.ID = P.CLIENT_REF
JOIN PRODUCT_TYPE PT ON P.PRODUCT_TYPE_ID = PT.ID
JOIN ACCOUNTS A ON P.ID = A.PRODUCT_REF
WHERE PT.NAME = 'КРЕДИТ' 
AND A.SALDO = 0 
AND P.CLOSE_DATE IS NULL;
```

---

### 9. Закрытие продуктов "КРЕДИТ" после полного погашения:
```sql
UPDATE PRODUCTS
SET CLOSE_DATE = CURRENT_DATE
WHERE ID IN (
    SELECT P.ID
    FROM PRODUCTS P
    JOIN ACCOUNTS A ON P.ID = A.PRODUCT_REF
    JOIN PRODUCT_TYPE PT ON P.PRODUCT_TYPE_ID = PT.ID
    WHERE PT.NAME = 'КРЕДИТ'
    AND A.SALDO = 0
    AND NOT EXISTS (SELECT 1 FROM RECORDS R WHERE R.ACC_REF = A.ID AND R.DT = 1)
);
```

---

### 10. Закрытие возможности открытия продуктов без движения более месяца:
```sql
UPDATE PRODUCT_TYPE 
SET END_DATE = CURRENT_DATE
WHERE ID IN (
    SELECT PT.ID 
    FROM PRODUCT_TYPE PT
    JOIN PRODUCTS P ON PT.ID = P.PRODUCT_TYPE_ID
    JOIN ACCOUNTS A ON P.ID = A.PRODUCT_REF
    LEFT JOIN RECORDS R ON A.ID = R.ACC_REF
    WHERE R.ID IS NULL OR R.OPER_DATE < CURRENT_DATE - INTERVAL '1 month'
);
```

---

### 11. Добавление суммы договора:
```sql
ALTER TABLE PRODUCTS ADD COLUMN CONTRACT_AMOUNT DECIMAL(15,2);

UPDATE PRODUCTS P
SET CONTRACT_AMOUNT = (
    SELECT MAX(R.SUM) 
    FROM RECORDS R 
    JOIN ACCOUNTS A ON R.ACC_REF = A.ID
    WHERE A.PRODUCT_REF = P.ID
    AND (
        (P.PRODUCT_TYPE_ID = (SELECT ID FROM PRODUCT_TYPE WHERE NAME = 'КРЕДИТ') AND R.DT = 1) OR
        (P.PRODUCT_TYPE_ID IN (SELECT ID FROM PRODUCT_TYPE WHERE NAME IN ('ДЕПОЗИТ', 'КАРТА')) AND R.DT = 0)
    )
);
```
